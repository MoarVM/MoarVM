# This file automatically generated by tools\build\gen-cat.pl

# From src\how\Archetypes.pm

# Provides various properties of the type of type a given meta-object
# implements. This are used in various ways by the compiler and meta-model
# to do correct code generation or to detect illegal use of types in
# contexts with certain requirements.
my knowhow Archetypes {
    # Can this serve as a nominal type? Implies memoizability
    # amongst other things.
    has $!nominal;

    # If it's not nominal, does it know how to provide a nominal
    # type part of itself?
    has $!nominalizable;

    # Can this be inherited from?
    has $!inheritable;

    # If it's not inheritable, does it know how to produce something
    # that is?
    has $!inheritalizable;

    # Can this be composed (either with flattening composition, or used
    # as a mixin)?
    has $!composable;

    # If it's not composable, does it know how to produce something
    # that is?
    has $!composalizable;

    # Is it generic, in the sense of "we don't know what type this is
    # yet"? Note that a parametric type would not be generic - even if
    # it has missing parts, it defines a type. A type variable is generic,
    # however. This tends to cause various kinds of late (or at least
    # delayed) reification. In some contexts, an unresolved generic is
    # fatal.
    has $!generic;

    # Is it a parametric type - that is, it has missing bits that need
    # to be filled out before it can be used? Unlike generic, something
    # that is parametric does define a type - though we may need the gaps
    # filled it before it's useful in some way.
    has $!parametric;

    method new(:$nominal, :$inheritable, :$composable, :$parametric) {
        my $arch := nqp::create(self);
        $arch.BUILD(:nominal($nominal), :inheritable($inheritable),
            :composable($composable), :parametric($parametric));
        $arch
    }

    method BUILD(:$nominal, :$inheritable, :$composable, :$parametric) {
        $!nominal := $nominal;
        $!inheritable := $inheritable;
        $!composable := $composable;
        $!parametric := $parametric;
    }

    method nominal() { nqp::ifnull($!nominal, 0) }
    method nominalizable() { nqp::ifnull($!nominalizable, 0) }
    method inheritable() { nqp::ifnull($!inheritable, 0) }
    method inheritalizable() { nqp::ifnull($!inheritalizable, 0) }
    method composable() { nqp::ifnull($!composable, 0) }
    method composalizable() { nqp::ifnull($!composalizable, 0) }
    method generic() { nqp::ifnull($!generic, 0) }
    method parametric() { nqp::ifnull($!parametric, 0) }
}
# From src\how\RoleToRoleApplier.pm

knowhow RoleToRoleApplier {
    method apply($target, @roles) {
        # Aggregate all of the methods sharing names.
        my %meth_info;
        for @roles {
            my @methods := $_.HOW.methods($_);
            for @methods {
                my $name := nqp::can($_, 'name') ?? $_.name !! nqp::getcodename($_);
                my $meth := $_;
                my @meth_list;
                if nqp::defined(%meth_info{$name}) {
                    @meth_list := %meth_info{$name};
                }
                else {
                    %meth_info{$name} := @meth_list;
                }
                my $found := 0;
                for @meth_list {
                    if $meth =:= $_ {
                        $found := 1;
                    }
                }
                unless $found {
                    nqp::push(@meth_list, $meth);
                }
            }
        }

        # Also need methods of target.
        my %target_meth_info;
        my @target_meths := $target.HOW.methods($target);
        for @target_meths {
            my $name := nqp::can($_, 'name') ?? $_.name !! nqp::getcodename($_);
            %target_meth_info{$name} := $_;
        }

        # Process method list.
        for %meth_info {
            my $name := nqp::iterkey_s($_);
            my @add_meths := %meth_info{$name};

            # Do we already have a method of this name? If so, ignore all of the
            # methods we have from elsewhere.
            unless nqp::defined(%target_meth_info{$name}) {
                # No methods in the target role. If only one, it's easy...
                if nqp::elems(@add_meths) == 1 {
                    $target.HOW.add_method($target, $name, @add_meths[0]);
                }
                else {
                    # More than one - add to collisions list.
                    $target.HOW.add_collision($target, $name);
                }
            }
        }

        # Now do the other bits.
        my @all_roles;
        for @roles {
            my $how := $_.HOW;

            # Compose is any attributes, unless there's a conflict.
            my @attributes := $how.attributes($_);
            for @attributes {
                my $add_attr := $_;
                my $skip := 0;
                my @cur_attrs := $target.HOW.attributes($target);
                for @cur_attrs {
                    if $_ =:= $add_attr {
                        $skip := 1;
                    }
                    else {
                        if $_.name eq $add_attr.name {
                            nqp::die("Attribute '" ~ $_.name ~ "' conflicts in role composition");
                        }
                    }
                }
                unless $skip {
                    $target.HOW.add_attribute($target, $add_attr);
                }
            }

            # Build up full list.
            # XXX Not really right yet...
            nqp::push(@all_roles, $_);
        }

        return @all_roles;
    }
}
# From src\how\NQPConcreteRoleHOW.pm

# This implements a concrete, parameterized instance of a role that
# can be composed into a class or mixed into an object.
knowhow NQPConcreteRoleHOW {
    ##
    ## Attributes
    ##

    # Name of the concrete role.
    has $!name;

    # What parametric role it was instantiated from.
    has $!instance_of;

    # Attributes and methods.
    has @!attributes;
    has %!methods;
    has @!multi_methods_to_incorporate;
    has @!collisions;

    # Other roles that this one does.
    has @!roles;

    # All composed in roles.
    has @!role_typecheck_list;

    # Have we been composed?
    has $!composed;

    my $archetypes := Archetypes.new( :nominal(1), :composable(1) );
    method archetypes() {
        $archetypes
    }

    ##
    ## Declarative
    ##

    # Creates a new instance of this meta-class.
    method new(:$name!, :$instance_of!) {
        my $obj := nqp::create(self);
        $obj.BUILD(:name($name), :instance_of($instance_of));
        $obj
    }

    method BUILD(:$name!, :$instance_of!) {
        $!name := $name;
        $!instance_of := $instance_of;
        @!attributes := nqp::list();
        %!methods := nqp::hash();
        @!multi_methods_to_incorporate := nqp::list();
        @!collisions := nqp::list();
        @!roles := nqp::list();
        @!role_typecheck_list := nqp::list();
        $!composed := 0;
    }

    # Create a new meta-object instance, and then a new type object
    # to go with it, and return that.
    method new_type(:$name = '<anon>', :$instance_of!) {
        my $metarole := self.new(:name($name), :instance_of($instance_of));
        nqp::newtype($metarole, 'Uninstantiable');
    }

    method add_method($obj, $name, $code_obj) {
        if nqp::existskey(%!methods, $name) {
            nqp::die("This role already has a method named " ~ $name);
        }
        %!methods{$name} := $code_obj;
    }

    method add_multi_method($obj, $name, $code_obj) {
        my %todo;
        %todo<name> := $name;
        %todo<code> := $code_obj;
        nqp::push(@!multi_methods_to_incorporate, %todo);
        $code_obj;
    }

    method add_attribute($obj, $meta_attr) {
        my $name := $meta_attr.name;
        for @!attributes {
            if $_.name eq $name {
                nqp::die("This role already has an attribute named " ~ $name);
            }
        }
        nqp::push(@!attributes, $meta_attr);
    }

    method add_parent($obj, $parent) {
        nqp::die("A role cannot inherit from a class in NQP")
    }

    method add_role($obj, $role) {
        nqp::push(@!roles, $role);
    }

    method add_collision($obj, $colliding_name) {
        nqp::push(@!collisions, $colliding_name);
    }

    # Compose the role. Beyond this point, no changes are allowed.
    method compose($obj) {
        # Incorporate roles. They're already instantiated. We need to
        # add to done list their instantiation source.
        if @!roles {
            for @!roles {
                nqp::push(@!role_typecheck_list, $_);
                nqp::push(@!role_typecheck_list, $_.HOW.instance_of($_));
            }
            RoleToRoleApplier.apply($obj, @!roles);
        }

        # Mark composed.
        $!composed := 1;
        nqp::settypecache($obj, [$obj.WHAT]);
        nqp::setmethcache($obj, {});
        nqp::setmethcacheauth($obj, 1);
        $obj
    }


    ##
    ## Introspecty
    ##

    method methods($obj, :$local) {
        my @meths;
        for %!methods {
            nqp::push(@meths, nqp::iterval($_));
        }
        @meths
    }

    method method_table($obj) {
        %!methods
    }

    method collisions($obj) {
        @!collisions
    }

    method name($obj) {
        $!name
    }

    method attributes($obj, :$local) {
        my @attrs;
        for @!attributes {
            nqp::push(@attrs, $_);
        }
        @attrs
    }

    method roles($obj) {
        @!roles
    }

    method role_typecheck_list($obj) {
        @!role_typecheck_list
    }

    method instance_of($obj) {
        $!instance_of
    }
}
# From src\how\RoleToClassApplier.pm

knowhow RoleToClassApplier {

    sub has_method($target, $name, $local) {
        my %mt := $target.HOW.method_table($target);
        nqp::existskey(%mt, $name);
    }

    sub has_attribute($target, $name) {
        my @attributes := $target.HOW.attributes($target, :local(1));
        for @attributes {
            if $_.name eq $name { return 1; }
        }
        return 0;
    }

    method apply($target, @roles) {
        # If we have many things to compose, then get them into a single helper
        # role first.
        my $to_compose;
        my $to_compose_meta;
        if nqp::elems(@roles) == 1 {
            $to_compose := @roles[0];
            $to_compose_meta := $to_compose.HOW;
        }
        else {
            $to_compose := NQPConcreteRoleHOW.new_type(:instance_of(NQPMu));
            $to_compose_meta := $to_compose.HOW;
            for @roles {
                $to_compose_meta.add_role($to_compose, $_);
            }
            $to_compose := $to_compose_meta.compose($to_compose);
        }

        # Collisions?
        my @collisions := $to_compose_meta.collisions($to_compose);
        for @collisions -> $name {
            unless has_method($target, $name, 1) {
                nqp::die("Method '$name' collides and a resolution must be provided by the class '" ~
                    $target.HOW.name($target) ~ "'");
            }
        }

        # Compose in any methods.
        my @methods := $to_compose_meta.methods($to_compose);
        for @methods {
            my $name := nqp::can($_, 'name') ?? $_.name !! nqp::getcodename($_);
            unless has_method($target, $name, 0) {
                $target.HOW.add_method($target, $name, $_);
            }
        }

        # Compose in any role attributes.
        my @attributes := $to_compose_meta.attributes($to_compose);
        for @attributes {
            if has_attribute($target, $_.name) {
                nqp::die("Attribute '" ~ $_.name ~ "' already exists in the class '" ~
                    $target.HOW.name($target) ~  "', but a role also wishes to compose it");
            }
            $target.HOW.add_attribute($target, $_);
        }

        # The full list of done roles is just the list of the one role we have
        # composed in.
        # XXX TODO
        my @done;
        @done[0] := $to_compose;
    }
}
# From src\how\NQPCurriedRoleHOW.pm

knowhow NQPCurriedRoleHOW {
    has $!curried_role;
    has @!pos_args;

    my $archetypes := Archetypes.new( :nominal(1), :composable(1), :parametric(1) );
    method archetypes() {
        $archetypes
    }

    method new(:$curried_role!, :@pos_args!) {
        my $obj := nqp::create(self);
        $obj.BUILD(:$curried_role, :@pos_args);
        $obj
    }

    method BUILD(:$curried_role!, :@pos_args!) {
        $!curried_role := $curried_role;
        @!pos_args := @pos_args;
    }

    method new_type($curried_role!, *@pos_args) {
        my $meta := self.new(:curried_role($curried_role), :pos_args(@pos_args));
        nqp::newtype($meta, 'Uninstantiable');
    }

    method specialize($obj, $class_arg) {
        $!curried_role.HOW.specialize($!curried_role, $class_arg, |@!pos_args);
    }

    method name($obj) {
        $!curried_role.HOW.name($!curried_role)
    }

    method curried_role($obj) {
        $!curried_role
    }
}
# From src\how\NQPParametricRoleHOW.pm

# This implements a parametric role (that is, one that has yet to be
# parameterized to get a concrete role that we can actually compose
# into a class or mix into an object). It also contains the logic to
# reify it into an actual role.
knowhow NQPParametricRoleHOW {
    ##
    ## Attributes
    ##

    # Name of the parametric role.
    has $!name;

    # Attributes and methods.
    has @!attributes;
    has %!methods;
    has @!multi_methods_to_incorporate;

    # Other roles that this one does.
    has @!roles;

    # Have we been composed?
    has $!composed;

    # The body block of the role. (If we were to support multiple role
    # variants with the same name, this would be a multi. However, we
    # don't do that in NQP.)
    has $!body_block;

    my $archetypes := Archetypes.new( :nominal(1), :composable(1), :parametric(1) );
    method archetypes() {
        $archetypes
    }

    ##
    ## Declarative
    ##

    # Creates a new instance of this meta-class.
    method new(:$name!) {
        my $obj := nqp::create(self);
        $obj.BUILD(:name($name));
        $obj
    }

    method BUILD(:$name!) {
        $!name := $name;
        @!attributes := nqp::list();
        %!methods := nqp::hash();
        @!multi_methods_to_incorporate := nqp::list();
        @!roles := nqp::list();
        $!composed := 0;
    }

    # Create a new meta-class instance, and then a new type object
    # to go with it, and return that.
    method new_type(:$name = '<anon>') {
        my $metarole := self.new(:name($name));
        nqp::setwho(nqp::newtype($metarole, 'Uninstantiable'), {});
    }

    method set_body_block($obj, $body_block) {
        $!body_block := $body_block;
    }

    method add_method($obj, $name, $code_obj) {
        if nqp::existskey(%!methods, $name) {
            nqp::die("This role already has a method named " ~ $name);
        }
        %!methods{$name} := $code_obj;
    }

    method add_multi_method($obj, $name, $code_obj) {
        my %todo;
        %todo<name> := $name;
        %todo<code> := $code_obj;
        nqp::push(@!multi_methods_to_incorporate, %todo);
        $code_obj;
    }

    method add_attribute($obj, $meta_attr) {
        my $name := $meta_attr.name;
        for @!attributes {
            if $_.name eq $name {
                nqp::die("This role already has an attribute named " ~ $name);
            }
        }
        nqp::push(@!attributes, $meta_attr);
    }

    method add_parent($obj, $parent) {
        nqp::die("A role cannot inherit from a class")
    }

    method add_role($obj, $role) {
        nqp::push(@!roles, $role);
    }

    # Compose the role. Beyond this point, no changes are allowed.
    method compose($obj) {
        $!composed := 1;
        nqp::settypecache($obj, [$obj.WHAT]);
        nqp::setmethcache($obj, {});
        nqp::setmethcacheauth($obj, 1);
        $obj
    }


    ##
    ## Parametricity
    ##

    # Method to indicate that this type is parametric.
    method parametric($obj) {
        1
    }

    # Curries this parametric role with arguments.
    method curry($obj, *@args) {
        NQPCurriedRoleHOW.new_type($obj, |@args)
    }

    # This specializes the role for the given class and builds a concrete
    # role.
    method specialize($obj, $class_arg, *@args) {
        # Run the body block to capture the arguments into the correct
        # type argument context.
        my $pad := $!body_block($class_arg, |@args);

        # Construct a new concrete role.
        my $irole := NQPConcreteRoleHOW.new_type(:name($!name), :instance_of($obj));

        # Copy attributes. (Nothing to reify in NQP as we don't currently
        # have parametric types that may end up in the signature.)
        for @!attributes {
            $irole.HOW.add_attribute($irole, $_);
        }

        # Capture methods in the correct lexical context.
        for %!methods {
            my $name := nqp::iterkey_s($_);
            my $meth := nqp::can(nqp::iterval($_), 'instantiate_generic')
                ?? nqp::iterval($_).instantiate_generic($pad)
                !! nqp::iterval($_).clone();
            if nqp::substr($name, 0, 12) eq '!!LATENAME!!' {
                $name := nqp::atkey($pad, nqp::substr($name, 12));
                $meth.'!set_name'($name);
            }
            $irole.HOW.add_method($irole, $name, $meth);
        }
        for @!multi_methods_to_incorporate {
            $irole.HOW.add_multi_method($irole, $_<name>, reify_method($_<code>));
        }

        # Copy roles, instantiating them as we go.
        for @!roles {
            my $specialized := $_.HOW.specialize($_, $class_arg);
            $irole.HOW.add_role($irole, $specialized);
        }

        # Compose and return produced role.
        $irole.HOW.compose($irole);
        return $irole;
    }

    ##
    ## Introspecty
    ##

    method methods($obj, :$local) {
        my @meths;
        for %!methods {
            nqp::push(@meths, nqp::iterval($_));
        }
        @meths
    }

    method method_table($obj) {
        %!methods
    }

    method name($obj) {
        $!name
    }

    method attributes($obj, :$local) {
        my @attrs;
        for @!attributes {
            nqp::push(@attrs, $_);
        }
        @attrs
    }

    method roles($obj) {
        @!roles
    }
}
# From src\how\NQPClassHOW.pm

# This is a first cut at a ClassHOW for NQP. It doesn't support all the stuff
# that Perl 6 needs, but it's sufficient for NQP. Supports methods, attributes,
# role composition, inheritance (single and multiple) and introspection.

knowhow NQPClassHOW {
    ##
    ## Attributes
    ##

    # Name of the class.
    has $!name;

    # Attributes, methods, parents and roles directly added.
    has @!attributes;
    has %!methods;
    has @!method_order;
    has @!multi_methods_to_incorporate;
    has @!parents;
    has @!roles;
    has $!default_parent;

    # Vtable and mapping of method names to slots.
    has @!vtable;
    has %!method-vtable-slots;

    # Have we been composed?
    has $!composed;

    # Cached MRO (list of the type objects).
    has @!mro;

    # Full list of roles that we do.
    has @!done;

    # Cached values, which are thrown away if the class changes.
    has %!caches;

    # Parrot-specific vtable mapping hash. Maps vtable name to method.
#    has %!parrot_vtable_mapping;
#	has %!parrot_vtable_handler_mapping;

    # Call tracing.
    has $!trace;
    has $!trace_depth;

    # Build plan.
    has @!BUILDALLPLAN;
    has @!BUILDPLAN;

    my $archetypes := Archetypes.new( :nominal(1), :inheritable(1) );
    method archetypes() {
        $archetypes
    }

    ##
    ## Declarative.
    ##

    # Creates a new instance of this meta-class.
    method new(:$name = '<anon>') {
        my $obj := nqp::create(self);
        $obj.BUILD(:name($name));
        $obj
    }

    method BUILD(:$name = '<anon>') {
        $!name := $name;
        @!attributes := nqp::list();
        %!methods := nqp::hash();
        @!method_order := nqp::list();
        @!multi_methods_to_incorporate := nqp::list();
        @!parents := nqp::list();
        @!roles := nqp::list();
        @!vtable := nqp::list();
        %!method-vtable-slots := nqp::hash();
        @!mro := nqp::list();
        @!done := nqp::list();
#        %!parrot_vtable_mapping := nqp::hash();
#        %!parrot_vtable_handler_mapping := nqp::hash();
        @!BUILDALLPLAN := nqp::list();
        @!BUILDPLAN := nqp::list();
        $!trace := 0;
        $!trace_depth := 0;
        $!composed := 0;
    }

    # Create a new meta-class instance, and then a new type object
    # to go with it, and return that.
    method new_type(:$name = '<anon>', :$repr = 'P6opaque') {
        my $metaclass := self.new(:name($name));
        nqp::setwho(nqp::newtype($metaclass, $repr), {});
    }

    method add_method($obj, $name, $code_obj) {
        if nqp::existskey(%!methods, $name) {
            nqp::die("This class already has a method named " ~ $name);
        }
        if nqp::isnull($code_obj) || !nqp::defined($code_obj) {
            nqp::die("Cannot add a null method '$name' to class '$!name'");
        }
        nqp::setmethcacheauth($obj, 0);
        %!caches{nqp::where(self)} := {} unless nqp::isnull(%!caches);
        nqp::push(@!method_order, %!methods{$name} := $code_obj);
    }

    method add_multi_method($obj, $name, $code_obj) {
        # We can't incorporate these right away as we don't know all
        # parents yet, maybe, which influences whether we even can
        # have multis, need to generate a proto or worreva. So just
        # queue them up in a todo list and we handle it at class
        # composition time.
        my %todo;
        %todo<name> := $name;
        %todo<code> := $code_obj;
        nqp::push(@!multi_methods_to_incorporate, %todo);
        nqp::setmethcacheauth($obj, 0);
        $code_obj;
    }

    method add_attribute($obj, $meta_attr) {
        my $name := $meta_attr.name;
        for @!attributes {
            if $_.name eq $name {
                nqp::die("This class already has an attribute named " ~ $name);
            }
        }
        nqp::push(@!attributes, $meta_attr);
    }

    method add_parent($obj, $parent) {
        if $!composed {
            nqp::die("NQPClassHOW does not support adding parents after being composed.");
        }
        if $obj =:= $parent {
            nqp::die("Class '$!name' cannot inherit from itself.");
        }
        for @!parents {
            if $_ =:= $parent {
                nqp::die("Already have " ~ $parent ~ " as a parent class.");
            }
        }
        nqp::push(@!parents, $parent);
    }

    method set_default_parent($obj, $parent) {
        $!default_parent := $parent;
    }

    # Changes the object's parent. Conditions: it has exactly one parent, and that
    # parent has no attributes, and nor does the new one.
    method reparent($obj, $new_parent) {
        if nqp::elems(@!parents) != 1 {
            nqp::die("Can only re-parent a class with exactly one parent");
        }
        for @!parents[0].HOW.mro(@!parents[0]) {
            if nqp::elems($_.HOW.attributes($_, :local)) {
                nqp::die("Can only re-parent a class whose parent has no attributes");
            }
        }
        for $new_parent.HOW.mro($new_parent) {
            if nqp::elems($_.HOW.attributes($_, :local)) {
                nqp::die("Can only re-parent to a class with no attributes");
            }
        }
        @!parents[0] := $new_parent;
        @!mro := compute_c3_mro($obj);
        self.publish_type_cache($obj);
        self.publish_method_cache($obj);
        self.publish_boolification_spec($obj);
#        self.publish_parrot_vtable_mapping($obj);
#		self.publish_parrot_vtablee_handler_mapping($obj);
        1;
    }

    method add_role($obj, $role) {
        for @!roles {
            if $_ =:= $role {
                nqp::die("The role " ~ $role ~ " has already been added.");
            }
        }
        nqp::push(@!roles, $role);
    }

#    method add_parrot_vtable_mapping($obj, $name, $meth) {
#        if nqp::defined(%!parrot_vtable_mapping{$name}) {
#            nqp::die("Class '" ~ $!name ~
#                "' already has a Parrot v-table override for '" ~
#                $name ~ "'");
#        }
#        %!parrot_vtable_mapping{$name} := $meth;
#    }
#
#    method add_parrot_vtable_handler_mapping($obj, $name, $att_name) {
#        if nqp::defined(%!parrot_vtable_handler_mapping{$name}) {
#            nqp::die("Class '" ~ $!name ~
#                "' already has a Parrot v-table handler for '" ~
#                $name ~ "'");
#        }
#        %!parrot_vtable_handler_mapping{$name} := [ $obj, $att_name ];
#    }

    method compose($obj) {
        # Incorporate roles. First, specialize them with the type object
        # for this type (so their $?CLASS is correct). Then delegate to
        # the composer.
        if @!roles {
            my @specialized_roles;
            for @!roles {
                my $ins := $_.HOW.specialize($_, $obj);
                nqp::push(@specialized_roles, $ins);
                nqp::push(@!done, $_);
                nqp::push(@!done, $ins);
            }
            RoleToClassApplier.apply($obj, @specialized_roles);
        }

        # If we have no parents and we're not called NQPMu then add the
        # default parent.
        if nqp::elems(@!parents) == 0 && $!name ne 'NQPMu' {
            self.add_parent($obj, $!default_parent)
        }

        # Compute the MRO.
        @!mro := compute_c3_mro($obj);

        # Incorporate any new multi candidates (needs MRO built).
        self.incorporate_multi_candidates($obj);

        # Compose attributes.
        for self.attributes($obj, :local<0> ) { $_.compose($obj) }

        # Publish type and method caches and boolification spec.
        self.publish_type_cache($obj);
        self.publish_method_cache($obj);
        self.publish_boolification_spec($obj);

        # Install Parrot v-table mapping.
#        self.publish_parrot_vtable_mapping($obj);
#		self.publish_parrot_vtablee_handler_mapping($obj);

        # Create BUILDPLAN.
        self.create_BUILDPLAN($obj);

        # Compose the representation.
        unless $!composed {
            self.compose_repr($obj);
        }

        # Mark as composed.
        $!composed := 1;

        $obj
    }

    method compose_repr($obj) {
        # Use any attribute information to produce attribute protocol
        # data. The protocol consists of an array...
        my @repr_info;

        # ...which contains an array per MRO entry...
        for @!mro -> $type_obj {
            my @type_info;
            nqp::push(@repr_info, @type_info);

            # ...which in turn contains the current type in the MRO...
            nqp::push(@type_info, $type_obj);

            # ...then an array of hashes per attribute...
            my @attrs;
            nqp::push(@type_info, @attrs);
            for $type_obj.HOW.attributes($type_obj, :local) -> $attr {
                my %attr_info;
                %attr_info<name> := $attr.name;
                %attr_info<type> := $attr.type;
                if $attr.box_target {
                    # Merely having the key serves as a "yes".
                    %attr_info<box_target> := 1;
                }
                if nqp::can($attr, 'auto_viv_container') {
                    %attr_info<auto_viv_container> := $attr.auto_viv_container;
                }
                if $attr.positional_delegate {
                    %attr_info<positional_delegate> := 1;
                }
                if $attr.associative_delegate {
                    %attr_info<associative_delegate> := 1;
                }
                nqp::push(@attrs, %attr_info);
            }

            # ...followed by a list of immediate parents.
            nqp::push(@type_info, $type_obj.HOW.parents($type_obj, :local));
        }

        # Compose the representation using it.
        my $info := nqp::hash();
        $info<attribute> := @repr_info;
        nqp::composetype($obj, $info)
    }

    method incorporate_multi_candidates($obj) {
        my $num_todo := nqp::elems(@!multi_methods_to_incorporate);
        my $i := 0;
        while $i != $num_todo {
            # Get method name and code.
            my $name := @!multi_methods_to_incorporate[$i]<name>;
            my $code := @!multi_methods_to_incorporate[$i]<code>;

            # Do we have anything in the methods table already in
            # this class?
            my $dispatcher := %!methods{$name};
            if nqp::defined($dispatcher) {
                # Yes. Only or dispatcher, though? If only, error. If
                # dispatcher, simply add new dispatchee.
                if nqp::can($dispatcher, 'is_dispatcher') && $dispatcher.is_dispatcher {
                    $dispatcher.add_dispatchee($code);
                }
                else {
                    nqp::die("Cannot have a multi candidate for $name when an only method is also in the class");
                }
            }
            else {
                # Go hunting in the MRO for a proto.
                my $j := 1;
                my $found := 0;
                while $j != nqp::elems(@!mro) && !$found {
                    my $parent := @!mro[$j];
                    my %meths := $parent.HOW.method_table($parent);
                    my $dispatcher := %meths{$name};
                    if nqp::defined($dispatcher) {
                        # Found a possible - make sure it's a dispatcher, not
                        # an only.
                        if nqp::can($dispatcher, 'is_dispatcher') && $dispatcher.is_dispatcher {
                            my $new_disp := $dispatcher.derive_dispatcher();
                            $new_disp.add_dispatchee($code);
                            %!methods{$name} := $new_disp;
                            $found := 1;
                        }
                        else {
                            nqp::die("Could not find a proto for multi $name (it may exist, but an only is hiding it if so)");
                        }
                    }
                    $j := $j + 1;
                }
                unless $found {
                    nqp::die("Could not find a proto for multi $name, and proto generation is NYI");
                }
            }
            $i := $i + 1;
        }
    }

    # Computes C3 MRO.
    sub compute_c3_mro($class) {
        my @immediate_parents := $class.HOW.parents($class, :local);

        # Provided we have immediate parents...
        my @result;
        if nqp::elems(@immediate_parents) {
            if nqp::elems(@immediate_parents) == 1 {
                @result := compute_c3_mro(@immediate_parents[0]);
            } else {
                # Build merge list of lineraizations of all our parents, add
                # immediate parents and merge.
                my @merge_list;
                for @immediate_parents {
                    nqp::push(@merge_list, compute_c3_mro($_));
                }
                nqp::push(@merge_list, @immediate_parents);
                @result := c3_merge(@merge_list);
            }
        }

        # Put this class on the start of the list, and we're done.
        nqp::unshift(@result, $class);
        return @result;
    }

    # C3 merge routine.
    sub c3_merge(@merge_list) {
        my @result;
        my $accepted;
        my $something_accepted := 0;
        my $cand_count := 0;

        # Try to find something appropriate to add to the MRO.
        for @merge_list {
            my @cand_list := $_;
            if @cand_list {
                my $rejected := 0;
                my $cand_class := @cand_list[0];
                $cand_count := $cand_count + 1;
                for @merge_list {
                    # Skip current list.
                    unless $_ =:= @cand_list {
                        # Is current candidate in the tail? If so, reject.
                        my $cur_pos := 1;
                        while $cur_pos <= nqp::elems($_) {
                            if $_[$cur_pos] =:= $cand_class {
                                $rejected := 1;
                            }
                            $cur_pos := $cur_pos + 1;
                        }
                    }
                }

                # If we didn't reject it, this candidate will do.
                unless $rejected {
                    $accepted := $cand_class;
                    $something_accepted := 1;
                    last;
                }
            }
        }

        # If we never found any candidates, return an empty list.
        if $cand_count == 0 {
            return @result;
        }

        # If we didn't find anything to accept, error.
        unless $something_accepted {
            nqp::die("Could not build C3 linearization: ambiguous hierarchy");
        }

        # Otherwise, remove what was accepted from the merge lists.
        my $i := 0;
        while $i < nqp::elems(@merge_list) {
            my @new_list;
            for @merge_list[$i] {
                unless $_ =:= $accepted {
                    nqp::push(@new_list, $_);
                }
            }
            @merge_list[$i] := @new_list;
            $i := $i + 1;
        }

        # Need to merge what remains of the list, then put what was accepted on
        # the start of the list, and we're done.
        @result := c3_merge(@merge_list);
        nqp::unshift(@result, $accepted);
        return @result;
    }

    method publish_type_cache($obj) {
        my @tc;
        for @!mro { nqp::push(@tc, $_); }
        for @!done { nqp::push(@tc, $_); }
        nqp::settypecache($obj, @tc)
    }

    sub reverse(@in) {
        my @out;
        for @in { nqp::unshift(@out, $_) }
        @out
    }

    method publish_method_cache($obj) {
        # Walk MRO and add methods to cache, unless another method
        # lower in the class hierarchy "shadowed" it.
        my %cache;
        my @mro_reversed := reverse(@!mro);
        for @mro_reversed {
            for $_.HOW.method_table($_) {
                %cache{nqp::iterkey_s($_)} := nqp::iterval($_);
            }
        }
        nqp::setmethcache($obj, %cache);
        nqp::setmethcacheauth($obj, 1);
    }

    method publish_boolification_spec($obj) {
        my $bool_meth := self.find_method($obj, 'Bool');
        if nqp::defined($bool_meth) {
            nqp::setboolspec($obj, 0, $bool_meth)
        }
        else {
            nqp::setboolspec($obj, 5, nqp::null())
        }
    }

#    method publish_parrot_vtable_mapping($obj) {
#        my %mapping;
#        my %seen_handlers;
#        for @!mro {
#            for $_.HOW.parrot_vtable_handler_mappings($_, :local(1)) {
#                %seen_handlers{$_.key} := 1;
#            }
#            for $_.HOW.parrot_vtable_mappings($_, :local(1)) {
#                unless nqp::existskey(%mapping, $_.key)
#                        || nqp::existskey(%seen_handlers, $_.key) {
#                    %mapping{$_.key} := $_.value;
#                }
#            }
#        }
#        if +%mapping {
#            pir::stable_publish_vtable_mapping__0PP($obj, %mapping);
#        }
#    }
#
#    method publish_parrot_vtablee_handler_mapping($obj) {
#        my %mapping;
#        my @mro_reversed := reverse(@!mro);
#        for @mro_reversed {
#            for $_.HOW.parrot_vtable_handler_mappings($_, :local(1)) {
#                %mapping{$_.key} := $_.value;
#            }
#        }
#        if +%mapping {
#            pir::stable_publish_vtable_handler_mapping__0PP($obj, %mapping);
#        }
#    }

    # Creates the plan for building up the object. This works
    # out what we'll need to do up front, so we can just zip
    # through the "todo list" each time we need to make an object.
    # The plan is an array of arrays. The first element of each
    # nested array is an "op" representing the task to perform:
    #   0 code = call specified BUILD method
    #   1 class name attr_name = try to find initialization value
    #   2 class name attr_name = try to find initialization value, or set nqp::list()
    #   3 class name attr_name = try to find initialization value, or set nqp::hash()
    #   4 class attr_name code = call default value closure if needed
    method create_BUILDPLAN($obj) {
        # First, we'll create the build plan for just this class.
        my @plan;
        my @attrs := $obj.HOW.attributes($obj, :local(1));

        # Does it have its own BUILD?
        my $build := $obj.HOW.method_table($obj)<BUILD>;
        if nqp::defined($build) {
            # We'll call the custom one.
            nqp::push(@plan, [0, $build]);
        }
        else {
            # No custom BUILD. Rather than having an actual BUILD
            # in Mu, we produce ops here per attribute that may
            # need initializing.
            for @attrs {
                my $attr_name := $_.name;
                my $name      := nqp::substr($attr_name, 2);
                my $sigil     := nqp::substr($attr_name, 0, 1);
                my $sigop     := $sigil eq '@' ?? 2 !! $sigil eq '%' ?? 3 !! 1;
                nqp::push(@plan, [$sigop, $obj, $name, $attr_name]);
            }
        }

        # Check if there's any default values to put in place.
        for @attrs {
            if nqp::can($_, 'build') {
                my $default := $_.build;
                if nqp::defined($default) {
                    nqp::push(@plan, [4, $obj, $_.name, $default]);
                }
            }
        }

        # Install plan for this class.
        @!BUILDPLAN := @plan;

        # Now create the full plan by getting the MRO, and working from
        # least derived to most derived, copying the plans.
        my @all_plan;
        my @mro := self.mro($obj);
        my $i := nqp::elems(@mro);
        while $i > 0 {
            $i := $i - 1;
            my $class := @mro[$i];
            for $class.HOW.BUILDPLAN($class) {
                nqp::push(@all_plan, $_);
            }
        }
        @!BUILDALLPLAN := @all_plan;
    }

    method BUILDPLAN($obj) {
        @!BUILDPLAN
    }

    method BUILDALLPLAN($obj) {
        @!BUILDALLPLAN
    }

    ##
    ## Introspecty
    ##

    method parents($obj, :$local = 0) {
        $local ?? @!parents !! @!mro
    }

    method mro($obj) {
        @!mro
    }

    method roles($obj, :$local!) {
        @!roles
    }

    method methods($obj, :$local = 0) {
        if $local {
            @!method_order
        }
        else {
            my @meths;
            for @!mro {
                for $_.HOW.methods($_, :local) {
                    nqp::push(@meths, $_)
                }
            }
            @meths
        }
    }

    method method_table($obj) {
        %!methods
    }

    method name($obj) {
        $!name
    }

    method traced($obj) {
        $!trace
    }

    method trace_depth($obj) {
        $!trace_depth
    }

    method attributes($obj, :$local = 0) {
        my @attrs;
        if $local {
            for @!attributes {
                nqp::push(@attrs, $_);
            }
        }
        else {
            for @!mro {
                for $_.HOW.attributes($_, :local) {
                    nqp::push(@attrs, $_);
                }
            }
        }
        @attrs
    }

#    method parrot_vtable_mappings($obj, :$local!) {
#        %!parrot_vtable_mapping
#    }
#
#    method parrot_vtable_handler_mappings($obj, :$local!) {
#        %!parrot_vtable_handler_mapping
#    }

    ##
    ## Checky
    ##

    method isa($obj, $check) {
        my $check-class := $check.WHAT;
        my $i := nqp::elems(@!mro);
        while $i > 0 {
            $i := $i - 1;
            if @!mro[$i] =:= $check-class {
                return 1;
            }
        }
        return 0;
    }

    method does($obj, $check) {
        my $i := nqp::elems(@!done);
        while $i > 0 {
            $i := $i - 1;
            if @!done[$i] =:= $check {
                return 1;
            }
        }
        return 0;
    }

    method can($obj, $name) {
        for @!mro {
            my %meths := $_.HOW.method_table($obj);
            my $can := %meths{$name};
            if nqp::defined($can) {
                return $can;
            }
        }
        return 0;
    }

    ##
    ## Dispatchy
    ##
    method find_method($obj, $name, :$no_fallback = 0, :$no_trace = 0) {
        for @!mro {
            my %meths := $_.HOW.method_table($obj);
            if nqp::existskey(%meths, $name) {
                my $found := %meths{$name};
                return $!trace && !$no_trace && nqp::substr($name, 0, 1) ne '!' ??
                    -> *@pos, *%named {
                        nqp::say(nqp::x('  ', $!trace_depth) ~ "Calling $name");
                        $!trace_depth := $!trace_depth + 1;
                        my $result := $found(|@pos, |%named);
                        $!trace_depth := $!trace_depth - 1;
                        $result
                    } !!
                    $found;
            }
        }
        nqp::null()
    }

    ##
    ## Cache-related
    ##
    method cache($obj, $key, $value_generator) {
        %!caches := nqp::hash() unless nqp::ishash(%!caches);
        nqp::existskey(%!caches, $key) ??
            %!caches{$key} !!
            (%!caches{$key} := $value_generator())
    }


    ##
    ## Mix-ins
    ##
    has @!mixin_cache;
    method mixin($obj, $role) {
        # See if we mixed in before.
        my $found := 0;
        my $new_type;
        unless nqp::isnull(@!mixin_cache) {
            for @!mixin_cache -> $c_role, $c_type {
                if $c_role =:= $role {
                    $new_type := $c_type;
                    $found := 1;
                    last;
                }
            }
        }

        # Create and cache mixin-type if needed.
        unless $found {
            # Work out a type name for the post-mixed-in role.
            my $new_name := self.name($obj) ~ '+{' ~ $role.HOW.name($role) ~ '}';

            # Create new type, derive it from ourself and then add
            # all the roles we're mixing it.
            $new_type := self.new_type(:name($new_name), :repr($obj.REPR));
            $new_type.HOW.add_parent($new_type, $obj.WHAT);
            $new_type.HOW.add_role($new_type, $role);
            $new_type.HOW.compose($new_type);

            # Store the type.
            nqp::scwbdisable();
            @!mixin_cache := [] if nqp::isnull(@!mixin_cache);
            nqp::push(@!mixin_cache, $role);
            nqp::push(@!mixin_cache, $new_type);
            nqp::scwbenable();
            1;
        }

        # If the original object was concrete, change its type by calling a
        # low level op. Otherwise, we just return the new type object
        nqp::isconcrete($obj) ??
            nqp::rebless($obj, $new_type) !!
            $new_type
    }

    ##
    ## Tracing
    ##
    method trace-on($obj, $depth?) {
        $!trace := 1;
        $!trace_depth := $depth // 0;
        nqp::setmethcacheauth($obj, 0);
        nqp::setmethcache($obj, nqp::hash());
    }
    method trace-off($obj) {
        $!trace := 0;
    }
}
# From src\how\NQPNativeHOW.pm

knowhow NQPNativeHOW {
    has $!name;
    has $!composed;

    my $archetypes := Archetypes.new( :nominal(1) );
    method archetypes() {
        $archetypes
    }

    method new(:$name) {
        my $obj := nqp::create(self);
        $obj.BUILD(:name($name));
        $obj
    }

    method BUILD(:$name) {
        $!name := $name;
        $!composed := 0;
    }

    # Create a new meta-class instance, and then a new type object
    # to go with it, and return that.
    # XXX Should check that this is an inlineable REPR.
    method new_type(:$name = '<anon>', :$repr!) {
        my $metaclass := self.new(:name($name));
        nqp::setwho(nqp::newtype($metaclass, $repr), {});
    }

    method add_method($obj, $name, $code_obj) {
        nqp::die("Native types may not have methods (must be boxed to call method)");
    }

    method add_multi_method($obj, $name, $code_obj) {
        nqp::die("Native types may not have methods (must be boxed to call method)");
    }

    method add_attribute($obj, $meta_attr) {
        nqp::die("Native types may not have attributes");
    }

    method compose($obj) {
        $!composed := 1;
    }

    method name($obj) {
        $!name
    }
}
# From src\how\NQPAttribute.pm

knowhow NQPAttribute {
    has $!name;
    has $!type;
    has $!has_type;
    has $!box_target;
    has $!default;
    has $!has_default;
    has $!positional_delegate;
    has $!associative_delegate;

    method new(:$name!, :$box_target, *%extra) {
        my $attr := nqp::create(self);
        $attr.BUILD(:name($name), |%extra, :box_target($box_target),
            :has_type(nqp::existskey(%extra, 'type')),
            :has_default(nqp::existskey(%extra, 'default')));
        $attr
    }

    method BUILD(:$name, :$type, :$has_type, :$box_target, :$default, :$has_default) {
        $!name := $name;
        $!type := $type;
        $!has_type := $has_type;
        $!box_target := $box_target;
        $!default := $default;
        $!has_default := $has_default;
    }

    method name() {
        $!name
    }

    method type() {
        $!has_type ?? $!type !! nqp::null()
    }

    method has_accessor() {
        0
    }

    method build_closure() {
        0
    }

    method box_target() {
        !nqp::isnull($!box_target) && $!box_target ?? 1 !! 0
    }

    method auto_viv_container() {
        $!has_default ?? $!default !! nqp::null()
    }

    method set_positional_delegate($value) {
        $!positional_delegate := $value;
    }

    method set_associative_delegate($value) {
        $!associative_delegate := $value;
    }

    method positional_delegate() {
        !nqp::isnull($!positional_delegate) && $!positional_delegate ?? 1 !! 0
    }

    method associative_delegate() {
        !nqp::isnull($!associative_delegate) && $!associative_delegate ?? 1 !! 0
    }

    method compose($obj) {
        $obj
    }
}
# From src\how\NQPModuleHOW.pm

knowhow NQPModuleHOW {
    has $!name;
    has $!composed;

    my $archetypes := Archetypes.new( );
    method archetypes() {
        $archetypes
    }

    method new(:$name) {
        my $obj := nqp::create(self);
        $obj.BUILD(:name($name));
        $obj
    }

    method BUILD(:$name) {
        $!name := $name;
        $!composed := 0;
    }

    # Create a new meta-class instance, and then a new type object
    # to go with it, and return that.
    method new_type(:$name = '<anon>') {
        my $metaclass := self.new(:name($name));
        nqp::setwho(nqp::newtype($metaclass, 'Uninstantiable'), {});
    }

    method add_method($obj, $name, $code_obj) {
        nqp::die("Modules may not have methods");
    }

    method add_multi_method($obj, $name, $code_obj) {
        nqp::die("Modules may not have methods");
    }

    method add_attribute($obj, $meta_attr) {
        nqp::die("Modules may not have attributes");
    }

    method compose($obj) {
        nqp::setmethcache($obj, my %empty);
        nqp::setmethcacheauth($obj, 1);
        $!composed := 1;
    }

    method find_method($obj, $name, *%opts) {
        nqp::null()
    }

    method name($obj) {
        $!name
    }
}
# From src\how\EXPORTHOW.pm

# Bind the HOWs into the EXPORTHOW package under the package declarator
# names.
my knowhow EXPORTHOW {
    ($?PACKAGE.WHO)<module>       := NQPModuleHOW;
    ($?PACKAGE.WHO)<class>        := NQPClassHOW;
    ($?PACKAGE.WHO)<class-attr>   := NQPAttribute;
    ($?PACKAGE.WHO)<grammar>      := NQPClassHOW;
    ($?PACKAGE.WHO)<grammar-attr> := NQPAttribute;
    ($?PACKAGE.WHO)<role>         := NQPParametricRoleHOW;
    ($?PACKAGE.WHO)<role-attr>    := NQPAttribute;
    ($?PACKAGE.WHO)<native>       := NQPNativeHOW;
}

# vim: set ft=perl6 nomodifiable :
