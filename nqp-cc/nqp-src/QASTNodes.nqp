# This file automatically generated by tools\build\gen-cat.pl

# From src\QAST\CompileTimeValue.nqp

# Composed or mixed in to any node that also has a compile-time known value.
role QAST::CompileTimeValue {
    has $!compile_time_value;

    method has_compile_time_value() {
        1
    }

    method compile_time_value() {
        $!compile_time_value
    }

    method set_compile_time_value($value) {
        $!compile_time_value := $value
    }
}
# From src\QAST\SpecialArg.nqp

role QAST::SpecialArg {
    has str $!named;
    has int $!flat;

    method named(*@value) {
        $!named := @value[0] if @value;
        !nqp::isnull_s($!named) ?? $!named !! ""
    }
    method flat(*@value)  { $!flat := @value[0] if @value; $!flat }
}
# From src\QAST\Node.nqp

class QAST::Node {
    # For children.
    has @!array is positional_delegate;

    # For annotations.
    has %!hash is associative_delegate;

    has $!node;
    has $!returns;
    has int $!arity;

    method new(*@children, *%options) {
        my $new := self.CREATE();
        nqp::bindattr($new, QAST::Node, '@!array', @children);
        nqp::bindattr($new, QAST::Node, '%!hash', nqp::hash());
        for %options {
            nqp::findmethod($new, $_.key)($new, $_.value);
        }
        $new;
    }

    method node(*@value)       { $!node := @value[0] if @value; $!node }
    method returns(*@value)    { $!returns := @value[0] if @value; $!returns }
    method arity(*@value)      { $!arity := @value[0] if @value; $!arity }

    method named(*@value) {
        if @value {
            self.HOW.mixin(self, QAST::SpecialArg);
            self.named(@value[0]);
        }
        else {
            ""
        }
    }
    method flat(*@value) {
        if @value {
            self.HOW.mixin(self, QAST::SpecialArg);
            self.flat(@value[0]);
        }
        else {
            0
        }
    }

    method has_compile_time_value() {
        0
    }

    method set_compile_time_value($value) {
        self.HOW.mixin(self, QAST::CompileTimeValue);
        self.set_compile_time_value($value);
    }

    method hash()          { %!hash }
    method list()          { @!array }
    method pop()           { nqp::pop(@!array) }
    method push($value)    { nqp::push(@!array, $value) }
    method shift()         { nqp::shift(@!array) }
    method unshift($value) { nqp::unshift(@!array, $value) }

    my %uniques;
    method unique($prefix) {
        my $id := nqp::existskey(%uniques, $prefix) ??
            (%uniques{$prefix} := %uniques{$prefix} + 1) !!
            (%uniques{$prefix} := 1);
        $prefix ~ '_' ~ $id
    }

    method shallow_clone() {
        my $clone := nqp::clone(self);
        nqp::bindattr($clone, QAST::Node, '@!array', nqp::clone(@!array));
        $clone
    }

    method substitute_inline_placeholders(@fillers) {
        nqp::die(self.HOW.name(self) ~ " does not support inlining");
    }

    method evaluate_unquotes(@unquotes) {
        nqp::die(self.HOW.name(self) ~ " does not support evaluating unquotes");
    }

    method dump($indent?) {
        unless nqp::defined($indent) {
            $indent := 0;
        }
        my @chunks := [
            nqp::x(' ', $indent), '- ', self.HOW.name(self),
        ];
        my $extra := self.dump_extra_node_info();
        if nqp::chars($extra) {
            nqp::push(@chunks, "($extra)");
        }
        if (self.node) {
            nqp::push(@chunks, ' ');
            nqp::push(@chunks, nqp::escape(self.node));
        }
        nqp::push(@chunks, "\n");
        self.dump_children($indent + 2, @chunks);
        return join('', @chunks);
    }

    method dump_children(int $indent, @onto) {
        for @!array {
            if nqp::istype($_, QAST::Node) {
                nqp::push(@onto, $_.dump($indent));
            }
            else {
                nqp::push(@onto, nqp::x(' ', $indent));
                nqp::push(@onto, '- ');
                nqp::push(@onto, ~$_);
                nqp::push(@onto, "\n");
            }
        }
    }

    method dump_extra_node_info() { '' }
}
# From src\QAST\Regex.nqp

class QAST::Regex is QAST::Node {
    has $!name;
    has str $!rxtype;
    has str $!subtype;
    has str $!backtrack;
    has int $!negate;
    has int $!min;
    has int $!max;

    method name(*@value)      { $!name := @value[0] if @value; $!name }
    method rxtype(*@value)    {
        $!rxtype := @value[0] if @value;
        !nqp::isnull_s($!rxtype) ?? $!rxtype !! ""
    }
    method subtype(*@value)   {
        $!subtype := @value[0] if @value;
        !nqp::isnull_s($!subtype) ?? $!subtype !! ""
    }
    method backtrack(*@value) {
        $!backtrack := @value[0] if @value;
        !nqp::isnull_s($!backtrack) ?? $!backtrack !! ""
    }
    method negate(*@value)    { $!negate := @value[0] if @value; $!negate }
    method min(*@value)       { $!min := @value[0] if @value; $!min }
    method max(*@value)       { $!max := @value[0] if @value; $!max }
}

# From src\QAST\IVal.nqp

class QAST::IVal is QAST::Node {
    has int $!value;
    method value(*@value) { $!value := @value[0] if @value; $!value }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }
    method dump_extra_node_info() { ~$!value }
}
# From src\QAST\NVal.nqp

class QAST::NVal is QAST::Node {
    has num $!value;
    method value(*@value) { $!value := @value[0] if @value; $!value }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }
    method dump_extra_node_info() { ~$!value }
}
# From src\QAST\SVal.nqp

class QAST::SVal is QAST::Node {
    has str $!value;
    method value(*@value) { $!value := @value[0] if @value; $!value }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }
    method dump_extra_node_info() {
        nqp::escape($!value);
    }
}
# From src\QAST\BVal.nqp

class QAST::BVal is QAST::Node {
    has $!value;
    method value(*@value) { $!value := @value[0] if @value; $!value }

    method evaluate_unquotes(@unquotes) {
        self
    }
    method dump_extra_node_info() { ~$!value }
}
# From src\QAST\WVal.nqp

class QAST::WVal is QAST::Node does QAST::CompileTimeValue {
    method value(*@value) {
        @value
            ?? self.set_compile_time_value(@value[0])
            !! self.compile_time_value()
    }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }
    method dump_extra_node_info() {
        my $v := self.compile_time_value();
        $v.HOW.name($v);
    }
}
# From src\QAST\Want.nqp

class QAST::Want is QAST::Node {
    method has_compile_time_value() {
        nqp::istype(self[0], QAST::Node)
            ?? self[0].has_compile_time_value()
            !! 0
    }

    method compile_time_value() {
        self[0].compile_time_value()
    }

    method substitute_inline_placeholders(@fillers) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].substitute_inline_placeholders(@fillers);
            $i := $i + 2;
        }
        $result
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 2;
        }
        $result
    }
}
# From src\QAST\Var.nqp

class QAST::Var is QAST::Node {
    has str $!name;
    has str $!scope;
    has str $!decl;
    has int $!slurpy;
    has $!default;

    method name(*@value) {
        $!name := @value[0] if @value;
        !nqp::isnull_s($!name) ?? $!name !! ""
    }
    method scope(*@value) {
        $!scope := @value[0] if @value;
        !nqp::isnull_s($!scope) ?? $!scope !! ""
    }
    method decl(*@value) {
        $!decl := @value[0] if @value;
        !nqp::isnull_s($!decl) ?? $!decl !! ""
    }
    method slurpy(*@value)  { $!slurpy := @value[0] if @value; $!slurpy }
    method default(*@value) { $!default := @value[0] if @value; $!default }

    method substitute_inline_placeholders(@fillers) {
        self
    }

    method evaluate_unquotes(@unquotes) {
        self
    }

    method dump_extra_node_info() {
        $!decl
            ?? "$!scope $!name :decl"
            !! "$!scope $!name";
    }
}
# From src\QAST\VarWithFallback.nqp

class QAST::VarWithFallback is QAST::Var {
    has $!fallback;
    method fallback(*@value) { $!fallback := @value[0] if @value; $!fallback }
}
# From src\QAST\Op.nqp

class QAST::Op is QAST::Node {
    has str $!name;
    has str $!op;
    has str $!childorder;

    method name(*@value) {
        $!name := @value[0] if @value;
        nqp::isnull_s($!name) ?? "" !! $!name
    }
    method op(*@value) {
        $!op := @value[0] if @value;
        nqp::isnull_s($!op) ?? "" !! $!op
    }
    method childorder(*@value) {
        $!childorder := @value[0] if @value;
        nqp::isnull_s($!childorder) ?? "" !! $!childorder
    }

    method substitute_inline_placeholders(@fillers) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].substitute_inline_placeholders(@fillers);
            $i := $i + 1;
        }
        $result
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 1;
        }
        $result
    }

    method dump_extra_node_info() {
        !nqp::isnull_s($!name) && nqp::chars($!name)
            ?? "$!op $!name"
            !! $!op;
    }
}
# From src\QAST\VM.nqp

class QAST::VM is QAST::Node {
    has %!alternatives;

    method new(*@children, *%alternatives) {
        my $obj := nqp::create(self);
        nqp::bindattr($obj, QAST::Node, '@!array', @children);
        nqp::bindattr($obj, QAST::Node, '%!hash', nqp::hash());
        nqp::bindattr($obj, QAST::VM, '%!alternatives', %alternatives);
        $obj
    }

    method supports($option) {
        nqp::existskey(%!alternatives, $option)
    }

    method alternative($option) {
        nqp::atkey(%!alternatives, $option)
    }
}
# From src\QAST\Stmts.nqp

class QAST::Stmts is QAST::Node {
    has $!resultchild;

    method resultchild(*@value) { $!resultchild := @value[0] if @value; $!resultchild }

    method substitute_inline_placeholders(@fillers) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].substitute_inline_placeholders(@fillers);
            $i := $i + 1;
        }
        $result
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 1;
        }
        $result
    }

    method dump_extra_node_info() {
        nqp::defined($!resultchild) ?? ":resultchild($!resultchild))" !! ''
    }
}
# From src\QAST\Stmt.nqp

class QAST::Stmt is QAST::Node {
    has $!resultchild;

    method resultchild(*@value) { $!resultchild := @value[0] if @value; $!resultchild }

    method substitute_inline_placeholders(@fillers) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].substitute_inline_placeholders(@fillers);
            $i := $i + 1;
        }
        $result
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 1;
        }
        $result
    }

    method dump_extra_node_info() {
        nqp::defined($!resultchild) ?? ":resultchild($!resultchild))" !! ''
    }
}
# From src\QAST\Block.nqp

class QAST::Block is QAST::Node {
    has str $!name;
    has str $!blocktype;
    has int $!custom_args;
    has str $!cuid;
    has %!symbol;

    method name(*@value) {
        $!name := @value[0] if @value;
        nqp::isnull_s($!name) ?? "" !! $!name
    }
    method blocktype(*@value) {
        $!blocktype := @value[0] if @value;
        nqp::isnull_s($!blocktype) ?? "" !! $!blocktype
    }
    method custom_args(*@value) { $!custom_args := @value[0] if @value; $!custom_args }

    my $cur_cuid := 0;
    my $cuid_suffix := ~nqp::time_n();

    method cuid(*@value) {
        if @value {
            # Set ID if we are provided one.
            $!cuid := @value[0];
        }
        elsif $!cuid {
            # If we already have an ID, return it.
            $!cuid
        }
        else {
            # Otherwise, generate one.
            $cur_cuid := $cur_cuid + 1;
            $!cuid := 'cuid_' ~ $cur_cuid ~ '_' ~ $cuid_suffix;
        }
    }

    method symbol($name, *%attrs) {
        %!symbol := nqp::hash() if nqp::isnull(%!symbol);
        if %attrs {
            %!symbol{$name} := %!symbol{$name} // {};
            for %attrs {
                %!symbol{$name}{$_.key} := $_.value;
            }
        }
        %!symbol{$name}
    }

    method symtable() {
        %!symbol := nqp::hash() if nqp::isnull(%!symbol);
        %!symbol
    }

    method evaluate_unquotes(@unquotes) {
        my $result := self.shallow_clone();
        my $i := 0;
        my $elems := +@(self);
        while $i < $elems {
            $result[$i] := self[$i].evaluate_unquotes(@unquotes);
            $i := $i + 1;
        }
        $result
    }
}
# From src\QAST\Unquote.nqp

class QAST::Unquote is QAST::Node {
    has int $!position;

    method position(*@value) {
        @value ?? ($!position := @value[0]) !! $!position
    }

    method evaluate_unquotes(@unquotes) {
        @unquotes[$!position];
    }
}
# From src\QAST\CompUnit.nqp

class QAST::CompUnit is QAST::Node {
    # The serialization context for the compilation unit.
    has $!sc;

    # Code reference block list for the serialization context.
    has $!code_ref_blocks;

    # Are we in compilation mode?
    has int $!compilation_mode;

    # Tasks we should run prior to deserialization (or, in the non-precompiled
    # case, just before everything else in this compilation unit).
    has @!pre_deserialize;

    # Tasks we should run after deserialization (or, in the non-precompiled
    # case, right after the pre-deserialize tasks).
    has @!post_deserialize;

    # Call to the repossession conflict resolution mechanism, to be invoked
    # on deserialization.
    has $!repo_conflict_resolver;

    # The HLL name.
    has $!hll;

    # What to run at the point the compilation unit is loaded.
    has $!load;

    # What to run if this is the main entry point.
    has $!main;

    method sc(*@value)       { $!sc := @value[0] if @value; $!sc }
    method hll(*@value)      { $!hll := @value[0] if @value; $!hll }
    method load(*@value)     { $!load := @value[0] if @value; $!load }
    method main(*@value)     { $!main := @value[0] if @value; $!main }

    method compilation_mode(*@value) {
        $!compilation_mode := @value[0] if @value; $!compilation_mode
    }
    method pre_deserialize(*@value) {
        @!pre_deserialize := @value[0] if @value;
        nqp::isnull(@!pre_deserialize) ?? [] !! @!pre_deserialize
    }
    method post_deserialize(*@value) {
        @!post_deserialize := @value[0] if @value;
        nqp::isnull(@!post_deserialize) ?? [] !! @!post_deserialize
    }
    method repo_conflict_resolver(*@value) {
        @value ?? ($!repo_conflict_resolver := @value[0]) !! $!repo_conflict_resolver
    }
    method code_ref_blocks(*@value) {
        $!code_ref_blocks := @value[0] if @value; $!code_ref_blocks
    }
}
# From src\QAST\InlinePlaceholder.nqp

# This indicates a place in a QAST tree that has been stashed for later
# inlining where one of the arguments to the inlined routine was used.
class QAST::InlinePlaceholder is QAST::Node {
    has int $!position;

    method position(*@value) {
        @value ?? ($!position := @value[0]) !! $!position
    }

    method substitute_inline_placeholders(@fillers) {
        if $!position < +@fillers {
            my $result := @fillers[$!position];
            if self.named || self.flat {
                $result := $result.shallow_clone();
                if self.named -> $name {
                    $result.named($name);
                }
                if self.flat {
                    $result.flat(1);
                }
            }
            $result
        }
        else {
            nqp::die("Inline placeholder index out of range")
        }
    }
}

# vim: set ft=perl6 nomodifiable :
